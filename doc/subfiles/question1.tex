% !TeX root = ../main.tex
\documentclass[class=article]{standalone}
\usepackage{listings}
\usepackage{amsthm}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Environnement deriv pour les dérivations
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newlength{\indentationFormule}
\setlength{\indentationFormule}{1.3em}
\newlength{\indentationTotaleFormule}
\newlength{\indentationCommentaire}
\setlength{\indentationCommentaire}{4em}
\newlength{\indentationDerivation}
\newlength{\largeurLangle}
\settowidth{\largeurLangle}{$\langle$\hspace*{.4em}}
\newlength{\largeurBoiteCommentaire}

\newenvironment{deriv}[1][\leftmargini]%
  {\setlength{\indentationDerivation}{#1}%
    \setlength{\indentationTotaleFormule}{\indentationFormule}
    \addtolength{\indentationTotaleFormule}{#1}
    \setlength{\largeurBoiteCommentaire}{\linewidth}
    \addtolength{\largeurBoiteCommentaire}{-\indentationFormule}
    \addtolength{\largeurBoiteCommentaire}{-\indentationCommentaire}
    \addtolength{\largeurBoiteCommentaire}{-\largeurLangle}
    \addtolength{\largeurBoiteCommentaire}{-\indentationDerivation}
    \begin{list}{}{\setlength{\leftmargin}{\indentationTotaleFormule}}
                   \setlength{\baselineskip}{1.3\baselineskip}
                   \item$}%
   {\hbox{}$\end{list}}  % \hbox{} évite des underfull lors d'usages
                         % sans \< et sans \commentaire (et avec
                         % des \\ pour changer de ligne).

\newcommand{\<}[1]{\\\hspace*{-\indentationFormule}\makebox(0,0)[bl]{$#1$}\hspace*{\indentationFormule}}

\newcommand{\commentaire}[1]{\hspace*{\indentationCommentaire}\langle\hspace*{.4em}%
    \begin{minipage}[t]{\largeurBoiteCommentaire}%
        #1 $\rangle$\\\hbox{}% Bizarre. Pourquoi ça prend \\ ici et aussi à la ligne suivante ?
                           % Sans \hbox{}, il y a des underfull.
    \end{minipage}\\[-1ex] % Sans ces deux \\, l'espace après un commentaire n'est pas le même quand
                           % le commentaire a plus d'une ligne.
}

\newcommand{\commentaireligne}[1]{$\mm ---#1$}{}
\newcommand{\sepcom}{\hspace{.4em}\&\hspace{.4em}\,}

%% Autre %%
\lstset{language=C++}
\newcommand{\BigO}{\mathcal{O}}





\begin{document}
\centerline{\Huge \bf Question 1}
\bigskip
\section*{Description textuelle}

L'algorithme se base sur ces observations suivantes:
\begin{enumerate}
    \item Zéro est l'élément absorbant de la multiplication;
    \item Le résultat est un produit d'éléments de vecteur (une multiplication);
    \item Lorsque deux zéro sont dans le vecteur, le produit sera toujours zéro;
    \item Nous pouvons émuler la non-production d'un élément, en divisant le produit par celui-ci, pour vu qu'il ne soit pas zéro.
\end{enumerate}

L'algorithme débute donc en initialisant une variable pour conserver le produit total (initialiser à 1), 
ainsi que deux variables "indicatices" (flags). Un pour conserver l'indice d'un élément absorbant et l'autre pour indiquer s'il y a plus d'un élément absorbant.

Puis, l'algorithme parcourt tous les éléments de notre vecteur entrant. S'il trouve pour la première fois un zéro, il affecter l'indice
où cet élément se trouve dans le vecteur. S'il en trouve un deuxième il affecte la valeur bouléen indiquant plusieurs zéros à vrai. 

Cette boucle terminée, il entre dans une des trois embranchements dépendanments de la valeur des variables indicatrices.

Premièrement, si la variable booléenne indiquant que plusieurs zéro ont été trouvés dans le vecteur entrant,
alors nous initialisons le vecteur résultat pour qu'il ne contienne que des zéros, puisque nous sommes garantis qu'il 
y aura une mutiplication par zéro pour tout ces éléments. 

Sinon, si la variable indiquant l'indice d'un zéro a été définie, alors tous les éléments du vecteur résultat seront
à zéro, à l'exception de l'élément à cet indice qui aura le résultat total du produit.

Finalement, si aucunne des deux variables indicatrices n'a été définie, alors chaque élément du vecteur résultat sera égale au produit, diviser par 
l'élément à l'indice correspondant du vecteur entrant.

\section*{Analyse de l'algorithme}

Puisque l'algorithme est trop complexe pour être analysé à l'aide d'une seule opératoire de base,
nous allons séparer l'algorithme en quatres parties et analyser chacune de ces parties individuellement,
puis conclure sur sur l'entièreté de l'algorithme à partir de ces sous-analyses.

La taille de l'instance est $n$, soit la cardinalité du vecteur entrant $A$.

\subsection*{Bloc A}

Le bloc A est composé de la première boucle \lstinline{for} et des déclarations lui précédents. 

Nous pouvons choisir comme opération de base le \lstinline{!productIsAlwaysZero}, car c'est la comparaison qui est effectué
le plus souvent, c'est-à-dire à chaque itération. De plus, la fonction \lstinline{A.at(i)} à l'intérieur de la boucle s'effectue en temps constant.


Le nombre de fois que cette opération de base peut s'exécuter dépendant du contenu du vecteur entrant ainsi que de sa cardinalité.

\subsubsection*{Meilleur cas}
En meilleur cas, les deux premiers éléments du vecteur sont 0. Si la boucle découvre deux 0, elle se courcircuite. Nous avons donc que:
\begin{deriv}
    C^A_{best}(n) = 3
    \<\Rightarrow
    \commentaire{Donc}
    1 \leq C^A_{best}(n) = 3 \leq 5
    \<\in 
    \commentaire{Définition de $\Theta$ avec $c_1 = 1$, $c_2 = 5$ et $n_0 = 0$}    
    \Theta(1)
\end{deriv}

\subsubsection*{Pire cas}
En pire cas, nous devons parcourir l'ensemble des éléments du vecteur entrant. À chacune des boucles, nous devons 
effectuer une seule comparaison, puis nous effectuons une dernière compairaison avant de sortir. Nous avons donc
\begin{deriv}
    C^A_{worst}(n) 
    \<= 
    \commentaire{Définition mathématique}
    \sum_{0}^{n-1}1 + 1
    \<=
    \commentaire{Première règle des sommations}
    (((n-1)-0+1) \times 1) + 1
    \<=
    \commentaire{Simplification}
    n + 1
    \<\Rightarrow
    \commentaire{Donc}
    \frac{1}{2}n \leq C^A_{worst}(n) = n + 1 \leq 2n $ $ {\forall n \geq 1}
    \<\in
    \commentaire{Définition de $\Theta$ avec $c_1 = \frac{1}{2}$, $c_2 = 2$ et $n_0 = 1$  }
    \Theta(n)
\end{deriv}
\end{document} 